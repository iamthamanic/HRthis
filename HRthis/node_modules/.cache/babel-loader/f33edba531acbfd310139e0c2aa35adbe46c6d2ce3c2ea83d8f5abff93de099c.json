{"ast":null,"code":"import _objectSpread from \"/Users/halteverbotsocialmacpro/Desktop/ars vivai/Worky Time/worky-time-web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncIterator from \"/Users/halteverbotsocialmacpro/Desktop/ars vivai/Worky Time/worky-time-web/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_response, _MessageStream_request_id, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage;\nimport { AnthropicError, APIUserAbortError } from '@anthropic-ai/sdk/error';\nimport { Stream } from '@anthropic-ai/sdk/streaming';\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nconst JSON_BUF_PROPERTY = '__json_buf';\nexport class MessageStream {\n  constructor() {\n    _MessageStream_instances.add(this);\n    this.messages = [];\n    this.receivedMessages = [];\n    _MessageStream_currentMessageSnapshot.set(this, void 0);\n    this.controller = new AbortController();\n    _MessageStream_connectedPromise.set(this, void 0);\n    _MessageStream_resolveConnectedPromise.set(this, () => {});\n    _MessageStream_rejectConnectedPromise.set(this, () => {});\n    _MessageStream_endPromise.set(this, void 0);\n    _MessageStream_resolveEndPromise.set(this, () => {});\n    _MessageStream_rejectEndPromise.set(this, () => {});\n    _MessageStream_listeners.set(this, {});\n    _MessageStream_ended.set(this, false);\n    _MessageStream_errored.set(this, false);\n    _MessageStream_aborted.set(this, false);\n    _MessageStream_catchingPromiseCreated.set(this, false);\n    _MessageStream_response.set(this, void 0);\n    _MessageStream_request_id.set(this, void 0);\n    _MessageStream_handleError.set(this, error => {\n      __classPrivateFieldSet(this, _MessageStream_errored, true, \"f\");\n      if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n      }\n      if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _MessageStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n      }\n      if (error instanceof AnthropicError) {\n        return this._emit('error', error);\n      }\n      if (error instanceof Error) {\n        const anthropicError = new AnthropicError(error.message);\n        // @ts-ignore\n        anthropicError.cause = error;\n        return this._emit('error', anthropicError);\n      }\n      return this._emit('error', new AnthropicError(String(error)));\n    });\n    __classPrivateFieldSet(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _MessageStream_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _MessageStream_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _MessageStream_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _MessageStream_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\").catch(() => {});\n  }\n  get response() {\n    return __classPrivateFieldGet(this, _MessageStream_response, \"f\");\n  }\n  get request_id() {\n    return __classPrivateFieldGet(this, _MessageStream_request_id, \"f\");\n  }\n  /**\n   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n   * returned vie the `request-id` header which is useful for debugging requests and resporting\n   * issues to Anthropic.\n   *\n   * This is the same as the `APIPromise.withResponse()` method.\n   *\n   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n   * as no `Response` is available.\n   */\n  async withResponse() {\n    const response = await __classPrivateFieldGet(this, _MessageStream_connectedPromise, \"f\");\n    if (!response) {\n      throw new Error('Could not resolve a `Response` object');\n    }\n    return {\n      data: this,\n      response,\n      request_id: response.headers.get('request-id')\n    };\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream) {\n    const runner = new MessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createMessage(messages, params, options) {\n    const runner = new MessageStream();\n    for (const message of params.messages) {\n      runner._addMessageParam(message);\n    }\n    runner._run(() => runner._createMessage(messages, _objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    }), _objectSpread(_objectSpread({}, options), {}, {\n      headers: _objectSpread(_objectSpread({}, options === null || options === void 0 ? void 0 : options.headers), {}, {\n        'X-Stainless-Helper-Method': 'stream'\n      })\n    })));\n    return runner;\n  }\n  _run(executor) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, __classPrivateFieldGet(this, _MessageStream_handleError, \"f\"));\n  }\n  _addMessageParam(message) {\n    this.messages.push(message);\n  }\n  _addMessage(message) {\n    let emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n  async _createMessage(messages, params, options) {\n    var _stream$controller$si;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n    const {\n      response,\n      data: stream\n    } = await messages.create(_objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    }), _objectSpread(_objectSpread({}, options), {}, {\n      signal: this.controller.signal\n    })).withResponse();\n    this._connected(response);\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const event = _step.value;\n        {\n          __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if ((_stream$controller$si = stream.controller.signal) !== null && _stream$controller$si !== void 0 && _stream$controller$si.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n  }\n  _connected(response) {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _MessageStream_response, response, \"f\");\n    __classPrivateFieldSet(this, _MessageStream_request_id, response === null || response === void 0 ? void 0 : response.headers.get('request-id'), \"f\");\n    __classPrivateFieldGet(this, _MessageStream_resolveConnectedPromise, \"f\").call(this, response);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _MessageStream_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _MessageStream_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _MessageStream_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\");\n  }\n  get currentMessage() {\n    return __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant Message response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalText() {\n    await this.done();\n    return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalText).call(this);\n  }\n  _emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // make sure we don't emit any MessageStreamEvents after end\n    if (__classPrivateFieldGet(this, _MessageStream_ended, \"f\")) return;\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _MessageStream_ended, true, \"f\");\n      __classPrivateFieldGet(this, _MessageStream_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(_ref => {\n        let {\n          listener\n        } = _ref;\n        return listener(...args);\n      });\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !(listeners !== null && listeners !== void 0 && listeners.length)) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !(listeners !== null && listeners !== void 0 && listeners.length)) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {\n    const finalMessage = this.receivedMessages.at(-1);\n    if (finalMessage) {\n      this._emit('finalMessage', __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this));\n    }\n  }\n  async _fromReadableStream(readableStream, options) {\n    var _stream$controller$si2;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n    this._connected(null);\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    var _iteratorAbruptCompletion2 = false;\n    var _didIteratorError2 = false;\n    var _iteratorError2;\n    try {\n      for (var _iterator2 = _asyncIterator(stream), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n        const event = _step2.value;\n        {\n          __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n          await _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n    if ((_stream$controller$si2 = stream.controller.signal) !== null && _stream$controller$si2 !== void 0 && _stream$controller$si2.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n  }\n  [(_MessageStream_currentMessageSnapshot = new WeakMap(), _MessageStream_connectedPromise = new WeakMap(), _MessageStream_resolveConnectedPromise = new WeakMap(), _MessageStream_rejectConnectedPromise = new WeakMap(), _MessageStream_endPromise = new WeakMap(), _MessageStream_resolveEndPromise = new WeakMap(), _MessageStream_rejectEndPromise = new WeakMap(), _MessageStream_listeners = new WeakMap(), _MessageStream_ended = new WeakMap(), _MessageStream_errored = new WeakMap(), _MessageStream_aborted = new WeakMap(), _MessageStream_catchingPromiseCreated = new WeakMap(), _MessageStream_response = new WeakMap(), _MessageStream_request_id = new WeakMap(), _MessageStream_handleError = new WeakMap(), _MessageStream_instances = new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    return this.receivedMessages.at(-1);\n  }, _MessageStream_getFinalText = function _MessageStream_getFinalText() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    const textBlocks = this.receivedMessages.at(-1).content.filter(block => block.type === 'text').map(block => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }, _MessageStream_beginRequest = function _MessageStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n  }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent(event) {\n    if (this.ended) return;\n    const messageSnapshot = __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_accumulateMessage).call(this, event);\n    this._emit('streamEvent', event, messageSnapshot);\n    switch (event.type) {\n      case 'content_block_delta':\n        {\n          const content = messageSnapshot.content.at(-1);\n          switch (event.delta.type) {\n            case 'text_delta':\n              {\n                if (content.type === 'text') {\n                  this._emit('text', event.delta.text, content.text || '');\n                }\n                break;\n              }\n            case 'citations_delta':\n              {\n                if (content.type === 'text') {\n                  var _content$citations;\n                  this._emit('citation', event.delta.citation, (_content$citations = content.citations) !== null && _content$citations !== void 0 ? _content$citations : []);\n                }\n                break;\n              }\n            case 'input_json_delta':\n              {\n                if (content.type === 'tool_use' && content.input) {\n                  this._emit('inputJson', event.delta.partial_json, content.input);\n                }\n                break;\n              }\n            case 'thinking_delta':\n              {\n                if (content.type === 'thinking') {\n                  this._emit('thinking', event.delta.thinking, content.thinking);\n                }\n                break;\n              }\n            case 'signature_delta':\n              {\n                if (content.type === 'thinking') {\n                  this._emit('signature', content.signature);\n                }\n                break;\n              }\n            default:\n              checkNever(event.delta);\n          }\n          break;\n        }\n      case 'message_stop':\n        {\n          this._addMessageParam(messageSnapshot);\n          this._addMessage(messageSnapshot, true);\n          break;\n        }\n      case 'content_block_stop':\n        {\n          this._emit('contentBlock', messageSnapshot.content.at(-1));\n          break;\n        }\n      case 'message_start':\n        {\n          __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n          break;\n        }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }, _MessageStream_endRequest = function _MessageStream_endRequest() {\n    if (this.ended) {\n      throw new AnthropicError(\"stream has ended, this shouldn't happen\");\n    }\n    const snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n    if (!snapshot) {\n      throw new AnthropicError(\"request ended without sending any chunks\");\n    }\n    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n    return snapshot;\n  }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage(event) {\n    let snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(\"Unexpected event order, got \".concat(event.type, \" before receiving \\\"message_stop\\\"\"));\n      }\n      return event.message;\n    }\n    if (!snapshot) {\n      throw new AnthropicError(\"Unexpected event order, got \".concat(event.type, \" before \\\"message_start\\\"\"));\n    }\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        snapshot.usage.output_tokens = event.usage.output_tokens;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta':\n        {\n          const snapshotContent = snapshot.content.at(event.index);\n          switch (event.delta.type) {\n            case 'text_delta':\n              {\n                if ((snapshotContent === null || snapshotContent === void 0 ? void 0 : snapshotContent.type) === 'text') {\n                  snapshotContent.text += event.delta.text;\n                }\n                break;\n              }\n            case 'citations_delta':\n              {\n                if ((snapshotContent === null || snapshotContent === void 0 ? void 0 : snapshotContent.type) === 'text') {\n                  var _snapshotContent$cita;\n                  (_snapshotContent$cita = snapshotContent.citations) !== null && _snapshotContent$cita !== void 0 ? _snapshotContent$cita : snapshotContent.citations = [];\n                  snapshotContent.citations.push(event.delta.citation);\n                }\n                break;\n              }\n            case 'input_json_delta':\n              {\n                if ((snapshotContent === null || snapshotContent === void 0 ? void 0 : snapshotContent.type) === 'tool_use') {\n                  // we need to keep track of the raw JSON string as well so that we can\n                  // re-parse it for each delta, for now we just store it as an untyped\n                  // non-enumerable property on the snapshot\n                  let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n                  jsonBuf += event.delta.partial_json;\n                  Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n                    value: jsonBuf,\n                    enumerable: false,\n                    writable: true\n                  });\n                  if (jsonBuf) {\n                    snapshotContent.input = partialParse(jsonBuf);\n                  }\n                }\n                break;\n              }\n            case 'thinking_delta':\n              {\n                if ((snapshotContent === null || snapshotContent === void 0 ? void 0 : snapshotContent.type) === 'thinking') {\n                  snapshotContent.thinking += event.delta.thinking;\n                }\n                break;\n              }\n            case 'signature_delta':\n              {\n                if ((snapshotContent === null || snapshotContent === void 0 ? void 0 : snapshotContent.type) === 'thinking') {\n                  snapshotContent.signature = event.delta.signature;\n                }\n                break;\n              }\n            default:\n              checkNever(event.delta);\n          }\n          return snapshot;\n        }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('streamEvent', event => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x) {}","map":{"version":3,"names":["AnthropicError","APIUserAbortError","Stream","partialParse","JSON_BUF_PROPERTY","MessageStream","constructor","messages","receivedMessages","_MessageStream_currentMessageSnapshot","set","controller","AbortController","_MessageStream_connectedPromise","_MessageStream_resolveConnectedPromise","_MessageStream_rejectConnectedPromise","_MessageStream_endPromise","_MessageStream_resolveEndPromise","_MessageStream_rejectEndPromise","_MessageStream_listeners","_MessageStream_ended","_MessageStream_errored","_MessageStream_aborted","_MessageStream_catchingPromiseCreated","_MessageStream_response","_MessageStream_request_id","_MessageStream_handleError","error","__classPrivateFieldSet","Error","name","_emit","anthropicError","message","cause","String","Promise","resolve","reject","__classPrivateFieldGet","catch","response","request_id","withResponse","data","headers","get","fromReadableStream","stream","runner","_run","_fromReadableStream","createMessage","params","options","_addMessageParam","_createMessage","_objectSpread","executor","then","_emitFinal","push","_addMessage","emit","arguments","length","undefined","_stream$controller$si","signal","aborted","abort","addEventListener","_MessageStream_instances","_MessageStream_beginRequest","call","create","_connected","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","event","value","_MessageStream_addStreamEvent","err","return","_MessageStream_endRequest","ended","errored","on","listener","listeners","off","index","findIndex","l","splice","once","emitted","currentMessage","finalMessage","_MessageStream_getFinalMessage","finalText","_MessageStream_getFinalText","_len","args","Array","_key","filter","forEach","_ref","at","readableStream","_stream$controller$si2","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","WeakMap","WeakSet","textBlocks","content","block","type","map","text","join","messageSnapshot","_MessageStream_accumulateMessage","delta","_content$citations","citation","citations","input","partial_json","thinking","signature","checkNever","snapshot","concat","stop_reason","stop_sequence","usage","output_tokens","content_block","snapshotContent","_snapshotContent$cita","jsonBuf","Object","defineProperty","enumerable","writable","Symbol","asyncIterator","pushQueue","readQueue","reader","shift","chunk","toReadableStream","bind","x"],"sources":["/Users/halteverbotsocialmacpro/Desktop/ars vivai/Worky Time/worky-time-web/node_modules/@anthropic-ai/sdk/src/lib/MessageStream.ts"],"sourcesContent":["import * as Core from \"../core.js\";\nimport { AnthropicError, APIUserAbortError } from \"../error.js\";\nimport {\n  type ContentBlock,\n  Messages,\n  type Message,\n  type MessageStreamEvent,\n  type MessageParam,\n  type MessageCreateParams,\n  type MessageCreateParamsBase,\n  type TextBlock,\n  type TextCitation,\n} from \"../resources/messages.js\";\nimport { type ReadableStream, type Response } from \"../_shims/index.js\";\nimport { Stream } from \"../streaming.js\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.js\";\n\nexport interface MessageStreamEvents {\n  connect: () => void;\n  streamEvent: (event: MessageStreamEvent, snapshot: Message) => void;\n  text: (textDelta: string, textSnapshot: string) => void;\n  citation: (citation: TextCitation, citationsSnapshot: TextCitation[]) => void;\n  inputJson: (partialJson: string, jsonSnapshot: unknown) => void;\n  thinking: (thinkingDelta: string, thinkingSnapshot: string) => void;\n  signature: (signature: string) => void;\n  message: (message: Message) => void;\n  contentBlock: (content: ContentBlock) => void;\n  finalMessage: (message: Message) => void;\n  error: (error: AnthropicError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n}\n\ntype MessageStreamEventListeners<Event extends keyof MessageStreamEvents> = {\n  listener: MessageStreamEvents[Event];\n  once?: boolean;\n}[];\n\nconst JSON_BUF_PROPERTY = '__json_buf';\n\nexport class MessageStream implements AsyncIterable<MessageStreamEvent> {\n  messages: MessageParam[] = [];\n  receivedMessages: Message[] = [];\n  #currentMessageSnapshot: Message | undefined;\n\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<Response | null>;\n  #resolveConnectedPromise: (response: Response | null) => void = () => {};\n  #rejectConnectedPromise: (error: AnthropicError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: AnthropicError) => void = () => {};\n\n  #listeners: { [Event in keyof MessageStreamEvents]?: MessageStreamEventListeners<Event> } = {};\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n  #response: Response | null | undefined;\n  #request_id: string | null | undefined;\n\n  constructor() {\n    this.#connectedPromise = new Promise<Response | null>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  get response(): Response | null | undefined {\n    return this.#response;\n  }\n\n  get request_id(): string | null | undefined {\n    return this.#request_id;\n  }\n\n  /**\n   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n   * returned vie the `request-id` header which is useful for debugging requests and resporting\n   * issues to Anthropic.\n   *\n   * This is the same as the `APIPromise.withResponse()` method.\n   *\n   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n   * as no `Response` is available.\n   */\n  async withResponse(): Promise<{\n    data: MessageStream;\n    response: Response;\n    request_id: string | null | undefined;\n  }> {\n    const response = await this.#connectedPromise;\n    if (!response) {\n      throw new Error('Could not resolve a `Response` object');\n    }\n\n    return {\n      data: this,\n      response,\n      request_id: response.headers.get('request-id'),\n    };\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): MessageStream {\n    const runner = new MessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createMessage(\n    messages: Messages,\n    params: MessageCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): MessageStream {\n    const runner = new MessageStream();\n    for (const message of params.messages) {\n      runner._addMessageParam(message);\n    }\n    runner._run(() =>\n      runner._createMessage(\n        messages,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  protected _run(executor: () => Promise<any>) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, this.#handleError);\n  }\n\n  protected _addMessageParam(message: MessageParam) {\n    this.messages.push(message);\n  }\n\n  protected _addMessage(message: Message, emit = true) {\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n\n  protected async _createMessage(\n    messages: Messages,\n    params: MessageCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const { response, data: stream } = await messages\n      .create({ ...params, stream: true }, { ...options, signal: this.controller.signal })\n      .withResponse();\n    this._connected(response);\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  protected _connected(response: Response | null) {\n    if (this.ended) return;\n    this.#response = response;\n    this.#request_id = response?.headers.get('request-id');\n    this.#resolveConnectedPromise(response);\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  on<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners: MessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  off<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  once<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners: MessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof MessageStreamEvents>(\n    event: Event,\n  ): Promise<\n    Parameters<MessageStreamEvents[Event]> extends [infer Param] ? Param\n    : Parameters<MessageStreamEvents[Event]> extends [] ? void\n    : Parameters<MessageStreamEvents[Event]>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  get currentMessage(): Message | undefined {\n    return this.#currentMessageSnapshot;\n  }\n\n  #getFinalMessage(): Message {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    return this.receivedMessages.at(-1)!;\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant Message response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalMessage(): Promise<Message> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalText(): string {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    const textBlocks = this.receivedMessages\n      .at(-1)!\n      .content.filter((block): block is TextBlock => block.type === 'text')\n      .map((block) => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalText(): Promise<string> {\n    await this.done();\n    return this.#getFinalText();\n  }\n\n  #handleError = (error: unknown) => {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof AnthropicError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const anthropicError: AnthropicError = new AnthropicError(error.message);\n      // @ts-ignore\n      anthropicError.cause = error;\n      return this._emit('error', anthropicError);\n    }\n    return this._emit('error', new AnthropicError(String(error)));\n  };\n\n  protected _emit<Event extends keyof MessageStreamEvents>(\n    event: Event,\n    ...args: Parameters<MessageStreamEvents[Event]>\n  ) {\n    // make sure we don't emit any MessageStreamEvents after end\n    if (this.#ended) return;\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: MessageStreamEventListeners<Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...args));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as AnthropicError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected _emitFinal() {\n    const finalMessage = this.receivedMessages.at(-1);\n    if (finalMessage) {\n      this._emit('finalMessage', this.#getFinalMessage());\n    }\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentMessageSnapshot = undefined;\n  }\n  #addStreamEvent(event: MessageStreamEvent) {\n    if (this.ended) return;\n    const messageSnapshot = this.#accumulateMessage(event);\n    this._emit('streamEvent', event, messageSnapshot);\n\n    switch (event.type) {\n      case 'content_block_delta': {\n        const content = messageSnapshot.content.at(-1)!;\n        switch (event.delta.type) {\n          case 'text_delta': {\n            if (content.type === 'text') {\n              this._emit('text', event.delta.text, content.text || '');\n            }\n            break;\n          }\n          case 'citations_delta': {\n            if (content.type === 'text') {\n              this._emit('citation', event.delta.citation, content.citations ?? []);\n            }\n            break;\n          }\n          case 'input_json_delta': {\n            if (content.type === 'tool_use' && content.input) {\n              this._emit('inputJson', event.delta.partial_json, content.input);\n            }\n            break;\n          }\n          case 'thinking_delta': {\n            if (content.type === 'thinking') {\n              this._emit('thinking', event.delta.thinking, content.thinking);\n            }\n            break;\n          }\n          case 'signature_delta': {\n            if (content.type === 'thinking') {\n              this._emit('signature', content.signature);\n            }\n            break;\n          }\n          default:\n            checkNever(event.delta);\n        }\n        break;\n      }\n      case 'message_stop': {\n        this._addMessageParam(messageSnapshot);\n        this._addMessage(messageSnapshot, true);\n        break;\n      }\n      case 'content_block_stop': {\n        this._emit('contentBlock', messageSnapshot.content.at(-1)!);\n        break;\n      }\n      case 'message_start': {\n        this.#currentMessageSnapshot = messageSnapshot;\n        break;\n      }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }\n  #endRequest(): Message {\n    if (this.ended) {\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentMessageSnapshot;\n    if (!snapshot) {\n      throw new AnthropicError(`request ended without sending any chunks`);\n    }\n    this.#currentMessageSnapshot = undefined;\n    return snapshot;\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected(null);\n    const stream = Stream.fromReadableStream<MessageStreamEvent>(readableStream, this.controller);\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  /**\n   * Mutates this.#currentMessage with the current event. Handling the accumulation of multiple messages\n   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple\n   * messages.\n   */\n  #accumulateMessage(event: MessageStreamEvent): Message {\n    let snapshot = this.#currentMessageSnapshot;\n\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n      }\n      return event.message;\n    }\n\n    if (!snapshot) {\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n    }\n\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        snapshot.usage.output_tokens = event.usage.output_tokens;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta': {\n        const snapshotContent = snapshot.content.at(event.index);\n\n        switch (event.delta.type) {\n          case 'text_delta': {\n            if (snapshotContent?.type === 'text') {\n              snapshotContent.text += event.delta.text;\n            }\n            break;\n          }\n          case 'citations_delta': {\n            if (snapshotContent?.type === 'text') {\n              snapshotContent.citations ??= [];\n              snapshotContent.citations.push(event.delta.citation);\n            }\n            break;\n          }\n          case 'input_json_delta': {\n            if (snapshotContent?.type === 'tool_use') {\n              // we need to keep track of the raw JSON string as well so that we can\n              // re-parse it for each delta, for now we just store it as an untyped\n              // non-enumerable property on the snapshot\n              let jsonBuf = (snapshotContent as any)[JSON_BUF_PROPERTY] || '';\n              jsonBuf += event.delta.partial_json;\n\n              Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n                value: jsonBuf,\n                enumerable: false,\n                writable: true,\n              });\n\n              if (jsonBuf) {\n                snapshotContent.input = partialParse(jsonBuf);\n              }\n            }\n            break;\n          }\n          case 'thinking_delta': {\n            if (snapshotContent?.type === 'thinking') {\n              snapshotContent.thinking += event.delta.thinking;\n            }\n            break;\n          }\n          case 'signature_delta': {\n            if (snapshotContent?.type === 'thinking') {\n              snapshotContent.signature = event.delta.signature;\n            }\n            break;\n          }\n          default:\n            checkNever(event.delta);\n        }\n\n        return snapshot;\n      }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<MessageStreamEvent> {\n    const pushQueue: MessageStreamEvent[] = [];\n    const readQueue: {\n      resolve: (chunk: MessageStreamEvent | undefined) => void;\n      reject: (error: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('streamEvent', (event) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<MessageStreamEvent>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<MessageStreamEvent | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x: never) {}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}