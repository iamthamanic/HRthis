{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BetaMessageStream_instances, _BetaMessageStream_currentMessageSnapshot, _BetaMessageStream_connectedPromise, _BetaMessageStream_resolveConnectedPromise, _BetaMessageStream_rejectConnectedPromise, _BetaMessageStream_endPromise, _BetaMessageStream_resolveEndPromise, _BetaMessageStream_rejectEndPromise, _BetaMessageStream_listeners, _BetaMessageStream_ended, _BetaMessageStream_errored, _BetaMessageStream_aborted, _BetaMessageStream_catchingPromiseCreated, _BetaMessageStream_response, _BetaMessageStream_request_id, _BetaMessageStream_getFinalMessage, _BetaMessageStream_getFinalText, _BetaMessageStream_handleError, _BetaMessageStream_beginRequest, _BetaMessageStream_addStreamEvent, _BetaMessageStream_endRequest, _BetaMessageStream_accumulateMessage;\nimport { AnthropicError, APIUserAbortError } from '@anthropic-ai/sdk/error';\nimport { Stream } from '@anthropic-ai/sdk/streaming';\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nconst JSON_BUF_PROPERTY = '__json_buf';\nexport class BetaMessageStream {\n  constructor() {\n    _BetaMessageStream_instances.add(this);\n    this.messages = [];\n    this.receivedMessages = [];\n    _BetaMessageStream_currentMessageSnapshot.set(this, void 0);\n    this.controller = new AbortController();\n    _BetaMessageStream_connectedPromise.set(this, void 0);\n    _BetaMessageStream_resolveConnectedPromise.set(this, () => {});\n    _BetaMessageStream_rejectConnectedPromise.set(this, () => {});\n    _BetaMessageStream_endPromise.set(this, void 0);\n    _BetaMessageStream_resolveEndPromise.set(this, () => {});\n    _BetaMessageStream_rejectEndPromise.set(this, () => {});\n    _BetaMessageStream_listeners.set(this, {});\n    _BetaMessageStream_ended.set(this, false);\n    _BetaMessageStream_errored.set(this, false);\n    _BetaMessageStream_aborted.set(this, false);\n    _BetaMessageStream_catchingPromiseCreated.set(this, false);\n    _BetaMessageStream_response.set(this, void 0);\n    _BetaMessageStream_request_id.set(this, void 0);\n    _BetaMessageStream_handleError.set(this, error => {\n      __classPrivateFieldSet(this, _BetaMessageStream_errored, true, \"f\");\n      if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n      }\n      if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _BetaMessageStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n      }\n      if (error instanceof AnthropicError) {\n        return this._emit('error', error);\n      }\n      if (error instanceof Error) {\n        const anthropicError = new AnthropicError(error.message);\n        // @ts-ignore\n        anthropicError.cause = error;\n        return this._emit('error', anthropicError);\n      }\n      return this._emit('error', new AnthropicError(String(error)));\n    });\n    __classPrivateFieldSet(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _BetaMessageStream_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _BetaMessageStream_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _BetaMessageStream_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _BetaMessageStream_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _BetaMessageStream_endPromise, \"f\").catch(() => {});\n  }\n  get response() {\n    return __classPrivateFieldGet(this, _BetaMessageStream_response, \"f\");\n  }\n  get request_id() {\n    return __classPrivateFieldGet(this, _BetaMessageStream_request_id, \"f\");\n  }\n  /**\n   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n   * returned vie the `request-id` header which is useful for debugging requests and resporting\n   * issues to Anthropic.\n   *\n   * This is the same as the `APIPromise.withResponse()` method.\n   *\n   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n   * as no `Response` is available.\n   */\n  async withResponse() {\n    const response = await __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, \"f\");\n    if (!response) {\n      throw new Error('Could not resolve a `Response` object');\n    }\n    return {\n      data: this,\n      response,\n      request_id: response.headers.get('request-id')\n    };\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream) {\n    const runner = new BetaMessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createMessage(messages, params, options) {\n    const runner = new BetaMessageStream();\n    for (const message of params.messages) {\n      runner._addMessageParam(message);\n    }\n    runner._run(() => runner._createMessage(messages, {\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        'X-Stainless-Helper-Method': 'stream'\n      }\n    }));\n    return runner;\n  }\n  _run(executor) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, __classPrivateFieldGet(this, _BetaMessageStream_handleError, \"f\"));\n  }\n  _addMessageParam(message) {\n    this.messages.push(message);\n  }\n  _addMessage(message, emit = true) {\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n  async _createMessage(messages, params, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_beginRequest).call(this);\n    const {\n      response,\n      data: stream\n    } = await messages.create({\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      signal: this.controller.signal\n    }).withResponse();\n    this._connected(response);\n    for await (const event of stream) {\n      __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_addStreamEvent).call(this, event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_endRequest).call(this);\n  }\n  _connected(response) {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _BetaMessageStream_response, response, \"f\");\n    __classPrivateFieldSet(this, _BetaMessageStream_request_id, response?.headers.get('request-id'), \"f\");\n    __classPrivateFieldGet(this, _BetaMessageStream_resolveConnectedPromise, \"f\").call(this, response);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _BetaMessageStream_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _BetaMessageStream_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _BetaMessageStream_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _BetaMessageStream_endPromise, \"f\");\n  }\n  get currentMessage() {\n    return __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant Message response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalMessage).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalText() {\n    await this.done();\n    return __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalText).call(this);\n  }\n  _emit(event, ...args) {\n    // make sure we don't emit any MessageStreamEvents after end\n    if (__classPrivateFieldGet(this, _BetaMessageStream_ended, \"f\")) return;\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _BetaMessageStream_ended, true, \"f\");\n      __classPrivateFieldGet(this, _BetaMessageStream_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _BetaMessageStream_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(({\n        listener\n      }) => listener(...args));\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {\n    const finalMessage = this.receivedMessages.at(-1);\n    if (finalMessage) {\n      this._emit('finalMessage', __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalMessage).call(this));\n    }\n  }\n  async _fromReadableStream(readableStream, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_beginRequest).call(this);\n    this._connected(null);\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    for await (const event of stream) {\n      __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_addStreamEvent).call(this, event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_endRequest).call(this);\n  }\n  [(_BetaMessageStream_currentMessageSnapshot = new WeakMap(), _BetaMessageStream_connectedPromise = new WeakMap(), _BetaMessageStream_resolveConnectedPromise = new WeakMap(), _BetaMessageStream_rejectConnectedPromise = new WeakMap(), _BetaMessageStream_endPromise = new WeakMap(), _BetaMessageStream_resolveEndPromise = new WeakMap(), _BetaMessageStream_rejectEndPromise = new WeakMap(), _BetaMessageStream_listeners = new WeakMap(), _BetaMessageStream_ended = new WeakMap(), _BetaMessageStream_errored = new WeakMap(), _BetaMessageStream_aborted = new WeakMap(), _BetaMessageStream_catchingPromiseCreated = new WeakMap(), _BetaMessageStream_response = new WeakMap(), _BetaMessageStream_request_id = new WeakMap(), _BetaMessageStream_handleError = new WeakMap(), _BetaMessageStream_instances = new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    return this.receivedMessages.at(-1);\n  }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    const textBlocks = this.receivedMessages.at(-1).content.filter(block => block.type === 'text').map(block => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n  }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent(event) {\n    if (this.ended) return;\n    const messageSnapshot = __classPrivateFieldGet(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_accumulateMessage).call(this, event);\n    this._emit('streamEvent', event, messageSnapshot);\n    switch (event.type) {\n      case 'content_block_delta':\n        {\n          const content = messageSnapshot.content.at(-1);\n          switch (event.delta.type) {\n            case 'text_delta':\n              {\n                if (content.type === 'text') {\n                  this._emit('text', event.delta.text, content.text || '');\n                }\n                break;\n              }\n            case 'citations_delta':\n              {\n                if (content.type === 'text') {\n                  this._emit('citation', event.delta.citation, content.citations ?? []);\n                }\n                break;\n              }\n            case 'input_json_delta':\n              {\n                if (content.type === 'tool_use' && content.input) {\n                  this._emit('inputJson', event.delta.partial_json, content.input);\n                }\n                break;\n              }\n            case 'thinking_delta':\n              {\n                if (content.type === 'thinking') {\n                  this._emit('thinking', event.delta.thinking, content.thinking);\n                }\n                break;\n              }\n            case 'signature_delta':\n              {\n                if (content.type === 'thinking') {\n                  this._emit('signature', content.signature);\n                }\n                break;\n              }\n            default:\n              checkNever(event.delta);\n          }\n          break;\n        }\n      case 'message_stop':\n        {\n          this._addMessageParam(messageSnapshot);\n          this._addMessage(messageSnapshot, true);\n          break;\n        }\n      case 'content_block_stop':\n        {\n          this._emit('contentBlock', messageSnapshot.content.at(-1));\n          break;\n        }\n      case 'message_start':\n        {\n          __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n          break;\n        }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest() {\n    if (this.ended) {\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n    if (!snapshot) {\n      throw new AnthropicError(`request ended without sending any chunks`);\n    }\n    __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n    return snapshot;\n  }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage(event) {\n    let snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n      }\n      return event.message;\n    }\n    if (!snapshot) {\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n    }\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        snapshot.usage.output_tokens = event.usage.output_tokens;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta':\n        {\n          const snapshotContent = snapshot.content.at(event.index);\n          switch (event.delta.type) {\n            case 'text_delta':\n              {\n                if (snapshotContent?.type === 'text') {\n                  snapshotContent.text += event.delta.text;\n                }\n                break;\n              }\n            case 'citations_delta':\n              {\n                if (snapshotContent?.type === 'text') {\n                  snapshotContent.citations ?? (snapshotContent.citations = []);\n                  snapshotContent.citations.push(event.delta.citation);\n                }\n                break;\n              }\n            case 'input_json_delta':\n              {\n                if (snapshotContent?.type === 'tool_use') {\n                  // we need to keep track of the raw JSON string as well so that we can\n                  // re-parse it for each delta, for now we just store it as an untyped\n                  // non-enumerable property on the snapshot\n                  let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n                  jsonBuf += event.delta.partial_json;\n                  Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n                    value: jsonBuf,\n                    enumerable: false,\n                    writable: true\n                  });\n                  if (jsonBuf) {\n                    snapshotContent.input = partialParse(jsonBuf);\n                  }\n                }\n                break;\n              }\n            case 'thinking_delta':\n              {\n                if (snapshotContent?.type === 'thinking') {\n                  snapshotContent.thinking += event.delta.thinking;\n                }\n                break;\n              }\n            case 'signature_delta':\n              {\n                if (snapshotContent?.type === 'thinking') {\n                  snapshotContent.signature = event.delta.signature;\n                }\n                break;\n              }\n            default:\n              checkNever(event.delta);\n          }\n          return snapshot;\n        }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('streamEvent', event => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x) {}","map":{"version":3,"names":["AnthropicError","APIUserAbortError","Stream","partialParse","JSON_BUF_PROPERTY","BetaMessageStream","constructor","messages","receivedMessages","_BetaMessageStream_currentMessageSnapshot","set","controller","AbortController","_BetaMessageStream_connectedPromise","_BetaMessageStream_resolveConnectedPromise","_BetaMessageStream_rejectConnectedPromise","_BetaMessageStream_endPromise","_BetaMessageStream_resolveEndPromise","_BetaMessageStream_rejectEndPromise","_BetaMessageStream_listeners","_BetaMessageStream_ended","_BetaMessageStream_errored","_BetaMessageStream_aborted","_BetaMessageStream_catchingPromiseCreated","_BetaMessageStream_response","_BetaMessageStream_request_id","_BetaMessageStream_handleError","error","__classPrivateFieldSet","Error","name","_emit","anthropicError","message","cause","String","Promise","resolve","reject","__classPrivateFieldGet","catch","response","request_id","withResponse","data","headers","get","fromReadableStream","stream","runner","_run","_fromReadableStream","createMessage","params","options","_addMessageParam","_createMessage","executor","then","_emitFinal","push","_addMessage","emit","signal","aborted","abort","addEventListener","_BetaMessageStream_instances","_BetaMessageStream_beginRequest","call","create","_connected","event","_BetaMessageStream_addStreamEvent","_BetaMessageStream_endRequest","ended","errored","on","listener","listeners","off","index","findIndex","l","splice","once","emitted","done","currentMessage","finalMessage","_BetaMessageStream_getFinalMessage","finalText","_BetaMessageStream_getFinalText","args","filter","forEach","length","at","readableStream","WeakMap","WeakSet","textBlocks","content","block","type","map","text","join","undefined","messageSnapshot","_BetaMessageStream_accumulateMessage","delta","citation","citations","input","partial_json","thinking","signature","checkNever","snapshot","stop_reason","stop_sequence","usage","output_tokens","content_block","snapshotContent","jsonBuf","Object","defineProperty","value","enumerable","writable","Symbol","asyncIterator","pushQueue","readQueue","reader","shift","err","next","chunk","return","toReadableStream","bind","x"],"sources":["/Users/halteverbotsocialmacpro/Desktop/ars vivai/Worky Time/worky-time-web/node_modules/@anthropic-ai/sdk/src/lib/BetaMessageStream.ts"],"sourcesContent":["import * as Core from \"../core.js\";\nimport { AnthropicError, APIUserAbortError } from \"../error.js\";\nimport {\n  type BetaContentBlock,\n  Messages as BetaMessages,\n  type BetaMessage,\n  type BetaRawMessageStreamEvent as BetaMessageStreamEvent,\n  type BetaMessageParam,\n  type MessageCreateParams as BetaMessageCreateParams,\n  type MessageCreateParamsBase as BetaMessageCreateParamsBase,\n  type BetaTextBlock,\n  type BetaTextCitation,\n} from \"../resources/beta/messages/messages.js\";\nimport { type ReadableStream, type Response } from \"../_shims/index.js\";\nimport { Stream } from \"../streaming.js\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.js\";\n\nexport interface MessageStreamEvents {\n  connect: () => void;\n  streamEvent: (event: BetaMessageStreamEvent, snapshot: BetaMessage) => void;\n  text: (textDelta: string, textSnapshot: string) => void;\n  citation: (citation: BetaTextCitation, citationsSnapshot: BetaTextCitation[]) => void;\n  inputJson: (partialJson: string, jsonSnapshot: unknown) => void;\n  thinking: (thinkingDelta: string, thinkingSnapshot: string) => void;\n  signature: (signature: string) => void;\n  message: (message: BetaMessage) => void;\n  contentBlock: (content: BetaContentBlock) => void;\n  finalMessage: (message: BetaMessage) => void;\n  error: (error: AnthropicError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n}\n\ntype MessageStreamEventListeners<Event extends keyof MessageStreamEvents> = {\n  listener: MessageStreamEvents[Event];\n  once?: boolean;\n}[];\n\nconst JSON_BUF_PROPERTY = '__json_buf';\n\nexport class BetaMessageStream implements AsyncIterable<BetaMessageStreamEvent> {\n  messages: BetaMessageParam[] = [];\n  receivedMessages: BetaMessage[] = [];\n  #currentMessageSnapshot: BetaMessage | undefined;\n\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<Response | null>;\n  #resolveConnectedPromise: (response: Response | null) => void = () => {};\n  #rejectConnectedPromise: (error: AnthropicError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: AnthropicError) => void = () => {};\n\n  #listeners: { [Event in keyof MessageStreamEvents]?: MessageStreamEventListeners<Event> } = {};\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n  #response: Response | null | undefined;\n  #request_id: string | null | undefined;\n\n  constructor() {\n    this.#connectedPromise = new Promise<Response | null>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  get response(): Response | null | undefined {\n    return this.#response;\n  }\n\n  get request_id(): string | null | undefined {\n    return this.#request_id;\n  }\n\n  /**\n   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n   * returned vie the `request-id` header which is useful for debugging requests and resporting\n   * issues to Anthropic.\n   *\n   * This is the same as the `APIPromise.withResponse()` method.\n   *\n   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n   * as no `Response` is available.\n   */\n  async withResponse(): Promise<{\n    data: BetaMessageStream;\n    response: Response;\n    request_id: string | null | undefined;\n  }> {\n    const response = await this.#connectedPromise;\n    if (!response) {\n      throw new Error('Could not resolve a `Response` object');\n    }\n\n    return {\n      data: this,\n      response,\n      request_id: response.headers.get('request-id'),\n    };\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): BetaMessageStream {\n    const runner = new BetaMessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createMessage(\n    messages: BetaMessages,\n    params: BetaMessageCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): BetaMessageStream {\n    const runner = new BetaMessageStream();\n    for (const message of params.messages) {\n      runner._addMessageParam(message);\n    }\n    runner._run(() =>\n      runner._createMessage(\n        messages,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  protected _run(executor: () => Promise<any>) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, this.#handleError);\n  }\n\n  protected _addMessageParam(message: BetaMessageParam) {\n    this.messages.push(message);\n  }\n\n  protected _addMessage(message: BetaMessage, emit = true) {\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n\n  protected async _createMessage(\n    messages: BetaMessages,\n    params: BetaMessageCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const { response, data: stream } = await messages\n      .create({ ...params, stream: true }, { ...options, signal: this.controller.signal })\n      .withResponse();\n    this._connected(response);\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  protected _connected(response: Response | null) {\n    if (this.ended) return;\n    this.#response = response;\n    this.#request_id = response?.headers.get('request-id');\n    this.#resolveConnectedPromise(response);\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  on<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners: MessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  off<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  once<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners: MessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof MessageStreamEvents>(\n    event: Event,\n  ): Promise<\n    Parameters<MessageStreamEvents[Event]> extends [infer Param] ? Param\n    : Parameters<MessageStreamEvents[Event]> extends [] ? void\n    : Parameters<MessageStreamEvents[Event]>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  get currentMessage(): BetaMessage | undefined {\n    return this.#currentMessageSnapshot;\n  }\n\n  #getFinalMessage(): BetaMessage {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    return this.receivedMessages.at(-1)!;\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant Message response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalMessage(): Promise<BetaMessage> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalText(): string {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    const textBlocks = this.receivedMessages\n      .at(-1)!\n      .content.filter((block): block is BetaTextBlock => block.type === 'text')\n      .map((block) => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalText(): Promise<string> {\n    await this.done();\n    return this.#getFinalText();\n  }\n\n  #handleError = (error: unknown) => {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof AnthropicError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const anthropicError: AnthropicError = new AnthropicError(error.message);\n      // @ts-ignore\n      anthropicError.cause = error;\n      return this._emit('error', anthropicError);\n    }\n    return this._emit('error', new AnthropicError(String(error)));\n  };\n\n  protected _emit<Event extends keyof MessageStreamEvents>(\n    event: Event,\n    ...args: Parameters<MessageStreamEvents[Event]>\n  ) {\n    // make sure we don't emit any MessageStreamEvents after end\n    if (this.#ended) return;\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: MessageStreamEventListeners<Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...args));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as AnthropicError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected _emitFinal() {\n    const finalMessage = this.receivedMessages.at(-1);\n    if (finalMessage) {\n      this._emit('finalMessage', this.#getFinalMessage());\n    }\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentMessageSnapshot = undefined;\n  }\n  #addStreamEvent(event: BetaMessageStreamEvent) {\n    if (this.ended) return;\n    const messageSnapshot = this.#accumulateMessage(event);\n    this._emit('streamEvent', event, messageSnapshot);\n\n    switch (event.type) {\n      case 'content_block_delta': {\n        const content = messageSnapshot.content.at(-1)!;\n        switch (event.delta.type) {\n          case 'text_delta': {\n            if (content.type === 'text') {\n              this._emit('text', event.delta.text, content.text || '');\n            }\n            break;\n          }\n          case 'citations_delta': {\n            if (content.type === 'text') {\n              this._emit('citation', event.delta.citation, content.citations ?? []);\n            }\n            break;\n          }\n          case 'input_json_delta': {\n            if (content.type === 'tool_use' && content.input) {\n              this._emit('inputJson', event.delta.partial_json, content.input);\n            }\n            break;\n          }\n          case 'thinking_delta': {\n            if (content.type === 'thinking') {\n              this._emit('thinking', event.delta.thinking, content.thinking);\n            }\n            break;\n          }\n          case 'signature_delta': {\n            if (content.type === 'thinking') {\n              this._emit('signature', content.signature);\n            }\n            break;\n          }\n          default:\n            checkNever(event.delta);\n        }\n        break;\n      }\n      case 'message_stop': {\n        this._addMessageParam(messageSnapshot);\n        this._addMessage(messageSnapshot, true);\n        break;\n      }\n      case 'content_block_stop': {\n        this._emit('contentBlock', messageSnapshot.content.at(-1)!);\n        break;\n      }\n      case 'message_start': {\n        this.#currentMessageSnapshot = messageSnapshot;\n        break;\n      }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }\n  #endRequest(): BetaMessage {\n    if (this.ended) {\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentMessageSnapshot;\n    if (!snapshot) {\n      throw new AnthropicError(`request ended without sending any chunks`);\n    }\n    this.#currentMessageSnapshot = undefined;\n    return snapshot;\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected(null);\n    const stream = Stream.fromReadableStream<BetaMessageStreamEvent>(readableStream, this.controller);\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  /**\n   * Mutates this.#currentMessage with the current event. Handling the accumulation of multiple messages\n   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple\n   * messages.\n   */\n  #accumulateMessage(event: BetaMessageStreamEvent): BetaMessage {\n    let snapshot = this.#currentMessageSnapshot;\n\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n      }\n      return event.message;\n    }\n\n    if (!snapshot) {\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n    }\n\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        snapshot.usage.output_tokens = event.usage.output_tokens;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta': {\n        const snapshotContent = snapshot.content.at(event.index);\n\n        switch (event.delta.type) {\n          case 'text_delta': {\n            if (snapshotContent?.type === 'text') {\n              snapshotContent.text += event.delta.text;\n            }\n            break;\n          }\n          case 'citations_delta': {\n            if (snapshotContent?.type === 'text') {\n              snapshotContent.citations ??= [];\n              snapshotContent.citations.push(event.delta.citation);\n            }\n            break;\n          }\n          case 'input_json_delta': {\n            if (snapshotContent?.type === 'tool_use') {\n              // we need to keep track of the raw JSON string as well so that we can\n              // re-parse it for each delta, for now we just store it as an untyped\n              // non-enumerable property on the snapshot\n              let jsonBuf = (snapshotContent as any)[JSON_BUF_PROPERTY] || '';\n              jsonBuf += event.delta.partial_json;\n\n              Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n                value: jsonBuf,\n                enumerable: false,\n                writable: true,\n              });\n\n              if (jsonBuf) {\n                snapshotContent.input = partialParse(jsonBuf);\n              }\n            }\n            break;\n          }\n          case 'thinking_delta': {\n            if (snapshotContent?.type === 'thinking') {\n              snapshotContent.thinking += event.delta.thinking;\n            }\n            break;\n          }\n          case 'signature_delta': {\n            if (snapshotContent?.type === 'thinking') {\n              snapshotContent.signature = event.delta.signature;\n            }\n            break;\n          }\n          default:\n            checkNever(event.delta);\n        }\n        return snapshot;\n      }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<BetaMessageStreamEvent> {\n    const pushQueue: BetaMessageStreamEvent[] = [];\n    const readQueue: {\n      resolve: (chunk: BetaMessageStreamEvent | undefined) => void;\n      reject: (error: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('streamEvent', (event) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<BetaMessageStreamEvent>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<BetaMessageStreamEvent | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x: never) {}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}