{"ast":null,"code":"import { create } from 'zustand';\nimport { persist, createJSONStorage } from 'zustand/middleware';\n// Mock data - simulating data from Timerecording.de API\nconst generateMockTimeRecords = userId => {\n  const records = [];\n  const today = new Date();\n\n  // Generate records for the last 30 days\n  for (let i = 29; i >= 0; i--) {\n    const date = new Date(today);\n    date.setDate(date.getDate() - i);\n\n    // Skip weekends\n    if (date.getDay() === 0 || date.getDay() === 6) continue;\n    const timeIn = new Date(date);\n    timeIn.setHours(8 + Math.floor(Math.random() * 2), Math.floor(Math.random() * 60));\n    const timeOut = new Date(timeIn);\n    timeOut.setHours(timeIn.getHours() + 8 + Math.floor(Math.random() * 2), Math.floor(Math.random() * 60));\n    const breakMinutes = 30 + Math.floor(Math.random() * 30);\n    const totalHours = (timeOut.getTime() - timeIn.getTime()) / (1000 * 60 * 60) - breakMinutes / 60;\n    records.push({\n      id: `${userId}-${date.toISOString().split('T')[0]}`,\n      userId,\n      date: date.toISOString().split('T')[0],\n      timeIn: timeIn.toTimeString().split(' ')[0].substring(0, 5),\n      timeOut: timeOut.toTimeString().split(' ')[0].substring(0, 5),\n      breakMinutes,\n      totalHours: Math.round(totalHours * 100) / 100\n    });\n  }\n  return records;\n};\nexport const useTimeRecordsStore = create()(persist((set, get) => ({\n  timeRecords: [],\n  isLoading: false,\n  currentlyTracking: {},\n  getTimeRecords: userId => {\n    let records = get().timeRecords.filter(record => record.userId === userId);\n\n    // If no records exist for this user, generate mock data\n    if (records.length === 0) {\n      const mockRecords = generateMockTimeRecords(userId);\n      set(state => ({\n        timeRecords: [...state.timeRecords, ...mockRecords]\n      }));\n      records = mockRecords;\n    }\n    return records.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n  },\n  getTimeRecordsForPeriod: (userId, startDate, endDate) => {\n    const allRecords = get().getTimeRecords(userId);\n    return allRecords.filter(record => record.date >= startDate && record.date <= endDate);\n  },\n  getMonthlyStats: (userId, month, year) => {\n    const allRecords = get().getTimeRecords(userId);\n    const monthRecords = allRecords.filter(record => {\n      const recordDate = new Date(record.date);\n      return recordDate.getMonth() === month && recordDate.getFullYear() === year;\n    });\n    const totalHours = monthRecords.reduce((sum, record) => sum + record.totalHours, 0);\n    return {\n      totalHours,\n      totalDays: monthRecords.length\n    };\n  },\n  getWeeklyStats: userId => {\n    const today = new Date();\n    const weekStart = new Date(today);\n    weekStart.setDate(today.getDate() - today.getDay() + 1); // Monday\n    weekStart.setHours(0, 0, 0, 0);\n    const weekEnd = new Date(weekStart);\n    weekEnd.setDate(weekStart.getDate() + 6); // Sunday\n    weekEnd.setHours(23, 59, 59, 999);\n    const allRecords = get().getTimeRecords(userId);\n    const weekRecords = allRecords.filter(record => {\n      const recordDate = new Date(record.date);\n      return recordDate >= weekStart && recordDate <= weekEnd;\n    });\n    const totalHours = weekRecords.reduce((sum, record) => sum + record.totalHours, 0);\n    return {\n      totalHours,\n      totalDays: weekRecords.length\n    };\n  },\n  getTodayRecord: userId => {\n    const today = new Date().toISOString().split('T')[0];\n    const records = get().getTimeRecords(userId);\n    return records.find(record => record.date === today) || null;\n  },\n  isCurrentlyTracking: userId => {\n    return !!get().currentlyTracking[userId];\n  },\n  clockIn: async userId => {\n    set({\n      isLoading: true\n    });\n    try {\n      const now = new Date();\n      const timeIn = now.toTimeString().split(' ')[0].substring(0, 5); // HH:MM\n      const today = now.toISOString().split('T')[0];\n\n      // Check if already clocked in today\n      const existingRecord = get().getTodayRecord(userId);\n      if (existingRecord && !existingRecord.timeOut) {\n        throw new Error('Bereits eingestempelt heute');\n      }\n\n      // If there's already a completed record today, create a new one\n      if (existingRecord && existingRecord.timeOut) {\n        throw new Error('Heute bereits vollständig erfasst. Bitte HR kontaktieren für Änderungen.');\n      }\n\n      // Create new time record\n      const newRecord = {\n        id: `${userId}-${today}-${Date.now()}`,\n        userId,\n        date: today,\n        timeIn,\n        breakMinutes: 0,\n        totalHours: 0\n      };\n\n      // Add to records and set tracking\n      set(state => ({\n        timeRecords: [...state.timeRecords, newRecord],\n        currentlyTracking: {\n          ...state.currentlyTracking,\n          [userId]: {\n            timeIn,\n            startTime: now.getTime()\n          }\n        },\n        isLoading: false\n      }));\n    } catch (error) {\n      set({\n        isLoading: false\n      });\n      throw error;\n    }\n  },\n  clockOut: async (userId, breakMinutes = 30) => {\n    set({\n      isLoading: true\n    });\n    try {\n      const now = new Date();\n      const timeOut = now.toTimeString().split(' ')[0].substring(0, 5); // HH:MM\n\n      // Find today's record\n      const todayRecord = get().getTodayRecord(userId);\n      if (!todayRecord || todayRecord.timeOut) {\n        throw new Error('Nicht eingestempelt oder bereits ausgestempelt');\n      }\n\n      // Calculate total hours\n      const timeInParts = todayRecord.timeIn.split(':');\n      const timeOutParts = timeOut.split(':');\n      const timeInMinutes = parseInt(timeInParts[0]) * 60 + parseInt(timeInParts[1]);\n      const timeOutMinutes = parseInt(timeOutParts[0]) * 60 + parseInt(timeOutParts[1]);\n      const totalMinutes = timeOutMinutes - timeInMinutes - breakMinutes;\n      const totalHours = Math.round(totalMinutes / 60 * 100) / 100;\n\n      // Update record\n      const updatedRecords = get().timeRecords.map(record => record.id === todayRecord.id ? {\n        ...record,\n        timeOut,\n        breakMinutes,\n        totalHours\n      } : record);\n      set(state => ({\n        timeRecords: updatedRecords,\n        currentlyTracking: {\n          ...state.currentlyTracking,\n          [userId]: null\n        },\n        isLoading: false\n      }));\n    } catch (error) {\n      set({\n        isLoading: false\n      });\n      throw error;\n    }\n  },\n  addTimeRecord: async record => {\n    set({\n      isLoading: true\n    });\n    try {\n      const newRecord = {\n        ...record,\n        id: `${record.userId}-${record.date}-${Date.now()}`\n      };\n      set(state => ({\n        timeRecords: [...state.timeRecords, newRecord],\n        isLoading: false\n      }));\n    } catch (error) {\n      set({\n        isLoading: false\n      });\n      throw error;\n    }\n  },\n  updateTimeRecord: async (recordId, updates) => {\n    set({\n      isLoading: true\n    });\n    try {\n      const updatedRecords = get().timeRecords.map(record => record.id === recordId ? {\n        ...record,\n        ...updates\n      } : record);\n      set({\n        timeRecords: updatedRecords,\n        isLoading: false\n      });\n    } catch (error) {\n      set({\n        isLoading: false\n      });\n      throw error;\n    }\n  },\n  deleteTimeRecord: async recordId => {\n    set({\n      isLoading: true\n    });\n    try {\n      const filteredRecords = get().timeRecords.filter(record => record.id !== recordId);\n      set({\n        timeRecords: filteredRecords,\n        isLoading: false\n      });\n    } catch (error) {\n      set({\n        isLoading: false\n      });\n      throw error;\n    }\n  },\n  setTimeRecords: records => {\n    set({\n      timeRecords: records\n    });\n  }\n}), {\n  name: 'time-records-storage',\n  storage: createJSONStorage(() => localStorage),\n  partialize: state => ({\n    timeRecords: state.timeRecords,\n    currentlyTracking: state.currentlyTracking\n  })\n}));","map":{"version":3,"names":["create","persist","createJSONStorage","generateMockTimeRecords","userId","records","today","Date","i","date","setDate","getDate","getDay","timeIn","setHours","Math","floor","random","timeOut","getHours","breakMinutes","totalHours","getTime","push","id","toISOString","split","toTimeString","substring","round","useTimeRecordsStore","set","get","timeRecords","isLoading","currentlyTracking","getTimeRecords","filter","record","length","mockRecords","state","sort","a","b","getTimeRecordsForPeriod","startDate","endDate","allRecords","getMonthlyStats","month","year","monthRecords","recordDate","getMonth","getFullYear","reduce","sum","totalDays","getWeeklyStats","weekStart","weekEnd","weekRecords","getTodayRecord","find","isCurrentlyTracking","clockIn","now","existingRecord","Error","newRecord","startTime","error","clockOut","todayRecord","timeInParts","timeOutParts","timeInMinutes","parseInt","timeOutMinutes","totalMinutes","updatedRecords","map","addTimeRecord","updateTimeRecord","recordId","updates","deleteTimeRecord","filteredRecords","setTimeRecords","name","storage","localStorage","partialize"],"sources":["/Users/halteverbotsocialmacpro/Desktop/ars vivai/HRthis/HRthis/src/state/timeRecords.ts"],"sourcesContent":["import { create } from 'zustand';\nimport { persist, createJSONStorage } from 'zustand/middleware';\nimport { TimeRecord } from '../types';\n\ninterface TimeRecordsState {\n  timeRecords: TimeRecord[];\n  isLoading: boolean;\n  currentlyTracking: { [userId: string]: { timeIn: string; startTime: number } | null };\n  getTimeRecords: (userId: string) => TimeRecord[];\n  getTimeRecordsForPeriod: (userId: string, startDate: string, endDate: string) => TimeRecord[];\n  getMonthlyStats: (userId: string, month: number, year: number) => { totalHours: number; totalDays: number };\n  getWeeklyStats: (userId: string) => { totalHours: number; totalDays: number };\n  getTodayRecord: (userId: string) => TimeRecord | null;\n  isCurrentlyTracking: (userId: string) => boolean;\n  clockIn: (userId: string) => Promise<void>;\n  clockOut: (userId: string, breakMinutes?: number) => Promise<void>;\n  addTimeRecord: (record: Omit<TimeRecord, 'id'>) => Promise<void>;\n  updateTimeRecord: (recordId: string, updates: Partial<TimeRecord>) => Promise<void>;\n  deleteTimeRecord: (recordId: string) => Promise<void>;\n  setTimeRecords: (records: TimeRecord[]) => void;\n}\n\n// Mock data - simulating data from Timerecording.de API\nconst generateMockTimeRecords = (userId: string): TimeRecord[] => {\n  const records: TimeRecord[] = [];\n  const today = new Date();\n  \n  // Generate records for the last 30 days\n  for (let i = 29; i >= 0; i--) {\n    const date = new Date(today);\n    date.setDate(date.getDate() - i);\n    \n    // Skip weekends\n    if (date.getDay() === 0 || date.getDay() === 6) continue;\n    \n    const timeIn = new Date(date);\n    timeIn.setHours(8 + Math.floor(Math.random() * 2), Math.floor(Math.random() * 60));\n    \n    const timeOut = new Date(timeIn);\n    timeOut.setHours(timeIn.getHours() + 8 + Math.floor(Math.random() * 2), Math.floor(Math.random() * 60));\n    \n    const breakMinutes = 30 + Math.floor(Math.random() * 30);\n    const totalHours = (timeOut.getTime() - timeIn.getTime()) / (1000 * 60 * 60) - (breakMinutes / 60);\n    \n    records.push({\n      id: `${userId}-${date.toISOString().split('T')[0]}`,\n      userId,\n      date: date.toISOString().split('T')[0],\n      timeIn: timeIn.toTimeString().split(' ')[0].substring(0, 5),\n      timeOut: timeOut.toTimeString().split(' ')[0].substring(0, 5),\n      breakMinutes,\n      totalHours: Math.round(totalHours * 100) / 100\n    });\n  }\n  \n  return records;\n};\n\nexport const useTimeRecordsStore = create<TimeRecordsState>()(\n  persist(\n    (set, get) => ({\n      timeRecords: [],\n      isLoading: false,\n      currentlyTracking: {},\n\n      getTimeRecords: (userId: string) => {\n        let records = get().timeRecords.filter(record => record.userId === userId);\n        \n        // If no records exist for this user, generate mock data\n        if (records.length === 0) {\n          const mockRecords = generateMockTimeRecords(userId);\n          set(state => ({\n            timeRecords: [...state.timeRecords, ...mockRecords]\n          }));\n          records = mockRecords;\n        }\n        \n        return records.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n      },\n\n      getTimeRecordsForPeriod: (userId: string, startDate: string, endDate: string) => {\n        const allRecords = get().getTimeRecords(userId);\n        return allRecords.filter(record => \n          record.date >= startDate && record.date <= endDate\n        );\n      },\n\n      getMonthlyStats: (userId: string, month: number, year: number) => {\n        const allRecords = get().getTimeRecords(userId);\n        const monthRecords = allRecords.filter(record => {\n          const recordDate = new Date(record.date);\n          return recordDate.getMonth() === month && recordDate.getFullYear() === year;\n        });\n        \n        const totalHours = monthRecords.reduce((sum, record) => sum + record.totalHours, 0);\n        return {\n          totalHours,\n          totalDays: monthRecords.length\n        };\n      },\n\n      getWeeklyStats: (userId: string) => {\n        const today = new Date();\n        const weekStart = new Date(today);\n        weekStart.setDate(today.getDate() - today.getDay() + 1); // Monday\n        weekStart.setHours(0, 0, 0, 0);\n        \n        const weekEnd = new Date(weekStart);\n        weekEnd.setDate(weekStart.getDate() + 6); // Sunday\n        weekEnd.setHours(23, 59, 59, 999);\n        \n        const allRecords = get().getTimeRecords(userId);\n        const weekRecords = allRecords.filter(record => {\n          const recordDate = new Date(record.date);\n          return recordDate >= weekStart && recordDate <= weekEnd;\n        });\n        \n        const totalHours = weekRecords.reduce((sum, record) => sum + record.totalHours, 0);\n        return {\n          totalHours,\n          totalDays: weekRecords.length\n        };\n      },\n\n      getTodayRecord: (userId: string) => {\n        const today = new Date().toISOString().split('T')[0];\n        const records = get().getTimeRecords(userId);\n        return records.find(record => record.date === today) || null;\n      },\n\n      isCurrentlyTracking: (userId: string) => {\n        return !!get().currentlyTracking[userId];\n      },\n\n      clockIn: async (userId: string) => {\n        set({ isLoading: true });\n        \n        try {\n          const now = new Date();\n          const timeIn = now.toTimeString().split(' ')[0].substring(0, 5); // HH:MM\n          const today = now.toISOString().split('T')[0];\n          \n          // Check if already clocked in today\n          const existingRecord = get().getTodayRecord(userId);\n          if (existingRecord && !existingRecord.timeOut) {\n            throw new Error('Bereits eingestempelt heute');\n          }\n          \n          // If there's already a completed record today, create a new one\n          if (existingRecord && existingRecord.timeOut) {\n            throw new Error('Heute bereits vollständig erfasst. Bitte HR kontaktieren für Änderungen.');\n          }\n          \n          // Create new time record\n          const newRecord: TimeRecord = {\n            id: `${userId}-${today}-${Date.now()}`,\n            userId,\n            date: today,\n            timeIn,\n            breakMinutes: 0,\n            totalHours: 0\n          };\n          \n          // Add to records and set tracking\n          set(state => ({\n            timeRecords: [...state.timeRecords, newRecord],\n            currentlyTracking: {\n              ...state.currentlyTracking,\n              [userId]: { timeIn, startTime: now.getTime() }\n            },\n            isLoading: false\n          }));\n        } catch (error) {\n          set({ isLoading: false });\n          throw error;\n        }\n      },\n\n      clockOut: async (userId: string, breakMinutes = 30) => {\n        set({ isLoading: true });\n        \n        try {\n          const now = new Date();\n          const timeOut = now.toTimeString().split(' ')[0].substring(0, 5); // HH:MM\n          \n          // Find today's record\n          const todayRecord = get().getTodayRecord(userId);\n          if (!todayRecord || todayRecord.timeOut) {\n            throw new Error('Nicht eingestempelt oder bereits ausgestempelt');\n          }\n          \n          // Calculate total hours\n          const timeInParts = todayRecord.timeIn.split(':');\n          const timeOutParts = timeOut.split(':');\n          const timeInMinutes = parseInt(timeInParts[0]) * 60 + parseInt(timeInParts[1]);\n          const timeOutMinutes = parseInt(timeOutParts[0]) * 60 + parseInt(timeOutParts[1]);\n          const totalMinutes = timeOutMinutes - timeInMinutes - breakMinutes;\n          const totalHours = Math.round((totalMinutes / 60) * 100) / 100;\n          \n          // Update record\n          const updatedRecords = get().timeRecords.map(record =>\n            record.id === todayRecord.id\n              ? { ...record, timeOut, breakMinutes, totalHours }\n              : record\n          );\n          \n          set(state => ({\n            timeRecords: updatedRecords,\n            currentlyTracking: {\n              ...state.currentlyTracking,\n              [userId]: null\n            },\n            isLoading: false\n          }));\n        } catch (error) {\n          set({ isLoading: false });\n          throw error;\n        }\n      },\n\n      addTimeRecord: async (record: Omit<TimeRecord, 'id'>) => {\n        set({ isLoading: true });\n        \n        try {\n          const newRecord: TimeRecord = {\n            ...record,\n            id: `${record.userId}-${record.date}-${Date.now()}`\n          };\n          \n          set(state => ({\n            timeRecords: [...state.timeRecords, newRecord],\n            isLoading: false\n          }));\n        } catch (error) {\n          set({ isLoading: false });\n          throw error;\n        }\n      },\n\n      updateTimeRecord: async (recordId: string, updates: Partial<TimeRecord>) => {\n        set({ isLoading: true });\n        \n        try {\n          const updatedRecords = get().timeRecords.map(record =>\n            record.id === recordId ? { ...record, ...updates } : record\n          );\n          \n          set({ timeRecords: updatedRecords, isLoading: false });\n        } catch (error) {\n          set({ isLoading: false });\n          throw error;\n        }\n      },\n\n      deleteTimeRecord: async (recordId: string) => {\n        set({ isLoading: true });\n        \n        try {\n          const filteredRecords = get().timeRecords.filter(record => record.id !== recordId);\n          \n          set({ timeRecords: filteredRecords, isLoading: false });\n        } catch (error) {\n          set({ isLoading: false });\n          throw error;\n        }\n      },\n\n      setTimeRecords: (records: TimeRecord[]) => {\n        set({ timeRecords: records });\n      }\n    }),\n    {\n      name: 'time-records-storage',\n      storage: createJSONStorage(() => localStorage),\n      partialize: (state) => ({ \n        timeRecords: state.timeRecords,\n        currentlyTracking: state.currentlyTracking\n      }),\n    }\n  )\n);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}