{"ast":null,"code":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\n/**\n * Represents a coin-based event or milestone that users can unlock\n */\n\n// Mock data for initial events\nconst mockEvents = [{\n  id: '1',\n  title: 'Bronze Status',\n  description: 'Achieve Bronze status and unlock basic perks',\n  requiredCoins: 100,\n  reward: 'Bronze badge + 5% discount on company merchandise',\n  isActive: true,\n  createdAt: new Date('2024-01-01').toISOString()\n}, {\n  id: '2',\n  title: 'Silver Status',\n  description: 'Level up to Silver status for enhanced benefits',\n  requiredCoins: 250,\n  reward: 'Silver badge + 10% discount + Priority support',\n  isActive: true,\n  createdAt: new Date('2024-01-01').toISOString()\n}, {\n  id: '3',\n  title: 'Gold Status',\n  description: 'Reach Gold status and enjoy premium perks',\n  requiredCoins: 500,\n  reward: 'Gold badge + 15% discount + VIP lounge access + 1 extra vacation day',\n  isActive: true,\n  createdAt: new Date('2024-01-01').toISOString()\n}, {\n  id: '4',\n  title: 'Platinum Status',\n  description: 'Achieve the highest status level with exclusive rewards',\n  requiredCoins: 1000,\n  reward: 'Platinum badge + 20% discount + Executive lounge + 2 extra vacation days + Personal assistant for 1 month',\n  isActive: true,\n  createdAt: new Date('2024-01-01').toISOString()\n}];\nexport const useCoinEventsStore = create()(persist((set, get) => ({\n  events: mockEvents,\n  isLoading: false,\n  getActiveEvents: () => {\n    return get().events.filter(event => event.isActive);\n  },\n  getUnlockedEvents: userBalance => {\n    return get().events.filter(event => event.isActive && userBalance >= event.requiredCoins);\n  },\n  getNextEvent: userBalance => {\n    const activeEvents = get().getActiveEvents();\n    const affordableEvents = activeEvents.filter(event => event.requiredCoins > userBalance).sort((a, b) => a.requiredCoins - b.requiredCoins);\n    return affordableEvents[0] || null;\n  },\n  addEvent: async eventData => {\n    set({\n      isLoading: true\n    });\n\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 500));\n    const newEvent = {\n      ...eventData,\n      id: Date.now().toString(),\n      createdAt: new Date().toISOString()\n    };\n    set(state => ({\n      events: [...state.events, newEvent],\n      isLoading: false\n    }));\n  },\n  updateEvent: async (eventId, updates) => {\n    set({\n      isLoading: true\n    });\n\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 500));\n    set(state => ({\n      events: state.events.map(event => event.id === eventId ? {\n        ...event,\n        ...updates\n      } : event),\n      isLoading: false\n    }));\n  },\n  deleteEvent: async eventId => {\n    set({\n      isLoading: true\n    });\n\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 500));\n    set(state => ({\n      events: state.events.filter(event => event.id !== eventId),\n      isLoading: false\n    }));\n  }\n}), {\n  name: 'coin-events-storage'\n}));","map":{"version":3,"names":["create","persist","mockEvents","id","title","description","requiredCoins","reward","isActive","createdAt","Date","toISOString","useCoinEventsStore","set","get","events","isLoading","getActiveEvents","filter","event","getUnlockedEvents","userBalance","getNextEvent","activeEvents","affordableEvents","sort","a","b","addEvent","eventData","Promise","resolve","setTimeout","newEvent","now","toString","state","updateEvent","eventId","updates","map","deleteEvent","name"],"sources":["/Users/halteverbotsocialmacpro/Desktop/ars vivai/HRthis/HRthis/src/state/coinEvents.ts"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\n/**\n * Represents a coin-based event or milestone that users can unlock\n */\nexport interface CoinEvent {\n  /** Unique identifier for the event */\n  id: string;\n  /** Display title of the event */\n  title: string;\n  /** Detailed description of the event */\n  description: string;\n  /** Number of coins required to unlock this event */\n  requiredCoins: number;\n  /** Description of what the user receives when unlocking this event */\n  reward: string;\n  /** Whether this event is currently active and available */\n  isActive: boolean;\n  /** ISO timestamp of when the event was created */\n  createdAt: string;\n}\n\ninterface CoinEventsState {\n  /** List of all coin events */\n  events: CoinEvent[];\n  /** Loading state for async operations */\n  isLoading: boolean;\n  \n  /** Get all currently active events */\n  getActiveEvents: () => CoinEvent[];\n  \n  /** Get events that the user has enough coins to unlock */\n  getUnlockedEvents: (userBalance: number) => CoinEvent[];\n  \n  /** Get the next event the user can work towards */\n  getNextEvent: (userBalance: number) => CoinEvent | null;\n  \n  /** Add a new coin event */\n  addEvent: (event: Omit<CoinEvent, 'id' | 'createdAt'>) => Promise<void>;\n  \n  /** Update an existing event */\n  updateEvent: (eventId: string, updates: Partial<CoinEvent>) => Promise<void>;\n  \n  /** Delete an event */\n  deleteEvent: (eventId: string) => Promise<void>;\n}\n\n// Mock data for initial events\nconst mockEvents: CoinEvent[] = [\n  {\n    id: '1',\n    title: 'Bronze Status',\n    description: 'Achieve Bronze status and unlock basic perks',\n    requiredCoins: 100,\n    reward: 'Bronze badge + 5% discount on company merchandise',\n    isActive: true,\n    createdAt: new Date('2024-01-01').toISOString(),\n  },\n  {\n    id: '2',\n    title: 'Silver Status',\n    description: 'Level up to Silver status for enhanced benefits',\n    requiredCoins: 250,\n    reward: 'Silver badge + 10% discount + Priority support',\n    isActive: true,\n    createdAt: new Date('2024-01-01').toISOString(),\n  },\n  {\n    id: '3',\n    title: 'Gold Status',\n    description: 'Reach Gold status and enjoy premium perks',\n    requiredCoins: 500,\n    reward: 'Gold badge + 15% discount + VIP lounge access + 1 extra vacation day',\n    isActive: true,\n    createdAt: new Date('2024-01-01').toISOString(),\n  },\n  {\n    id: '4',\n    title: 'Platinum Status',\n    description: 'Achieve the highest status level with exclusive rewards',\n    requiredCoins: 1000,\n    reward: 'Platinum badge + 20% discount + Executive lounge + 2 extra vacation days + Personal assistant for 1 month',\n    isActive: true,\n    createdAt: new Date('2024-01-01').toISOString(),\n  },\n];\n\nexport const useCoinEventsStore = create<CoinEventsState>()(\n  persist(\n    (set, get) => ({\n      events: mockEvents,\n      isLoading: false,\n\n      getActiveEvents: () => {\n        return get().events.filter(event => event.isActive);\n      },\n\n      getUnlockedEvents: (userBalance: number) => {\n        return get().events.filter(\n          event => event.isActive && userBalance >= event.requiredCoins\n        );\n      },\n\n      getNextEvent: (userBalance: number) => {\n        const activeEvents = get().getActiveEvents();\n        const affordableEvents = activeEvents\n          .filter(event => event.requiredCoins > userBalance)\n          .sort((a, b) => a.requiredCoins - b.requiredCoins);\n        \n        return affordableEvents[0] || null;\n      },\n\n      addEvent: async (eventData) => {\n        set({ isLoading: true });\n        \n        // Simulate API call\n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        const newEvent: CoinEvent = {\n          ...eventData,\n          id: Date.now().toString(),\n          createdAt: new Date().toISOString(),\n        };\n        \n        set(state => ({\n          events: [...state.events, newEvent],\n          isLoading: false,\n        }));\n      },\n\n      updateEvent: async (eventId, updates) => {\n        set({ isLoading: true });\n        \n        // Simulate API call\n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        set(state => ({\n          events: state.events.map(event =>\n            event.id === eventId ? { ...event, ...updates } : event\n          ),\n          isLoading: false,\n        }));\n      },\n\n      deleteEvent: async (eventId) => {\n        set({ isLoading: true });\n        \n        // Simulate API call\n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        set(state => ({\n          events: state.events.filter(event => event.id !== eventId),\n          isLoading: false,\n        }));\n      },\n    }),\n    {\n      name: 'coin-events-storage',\n    }\n  )\n);"],"mappings":"AAAA,SAASA,MAAM,QAAQ,SAAS;AAChC,SAASC,OAAO,QAAQ,oBAAoB;;AAE5C;AACA;AACA;;AA2CA;AACA,MAAMC,UAAuB,GAAG,CAC9B;EACEC,EAAE,EAAE,GAAG;EACPC,KAAK,EAAE,eAAe;EACtBC,WAAW,EAAE,8CAA8C;EAC3DC,aAAa,EAAE,GAAG;EAClBC,MAAM,EAAE,mDAAmD;EAC3DC,QAAQ,EAAE,IAAI;EACdC,SAAS,EAAE,IAAIC,IAAI,CAAC,YAAY,CAAC,CAACC,WAAW,CAAC;AAChD,CAAC,EACD;EACER,EAAE,EAAE,GAAG;EACPC,KAAK,EAAE,eAAe;EACtBC,WAAW,EAAE,iDAAiD;EAC9DC,aAAa,EAAE,GAAG;EAClBC,MAAM,EAAE,gDAAgD;EACxDC,QAAQ,EAAE,IAAI;EACdC,SAAS,EAAE,IAAIC,IAAI,CAAC,YAAY,CAAC,CAACC,WAAW,CAAC;AAChD,CAAC,EACD;EACER,EAAE,EAAE,GAAG;EACPC,KAAK,EAAE,aAAa;EACpBC,WAAW,EAAE,2CAA2C;EACxDC,aAAa,EAAE,GAAG;EAClBC,MAAM,EAAE,sEAAsE;EAC9EC,QAAQ,EAAE,IAAI;EACdC,SAAS,EAAE,IAAIC,IAAI,CAAC,YAAY,CAAC,CAACC,WAAW,CAAC;AAChD,CAAC,EACD;EACER,EAAE,EAAE,GAAG;EACPC,KAAK,EAAE,iBAAiB;EACxBC,WAAW,EAAE,yDAAyD;EACtEC,aAAa,EAAE,IAAI;EACnBC,MAAM,EAAE,2GAA2G;EACnHC,QAAQ,EAAE,IAAI;EACdC,SAAS,EAAE,IAAIC,IAAI,CAAC,YAAY,CAAC,CAACC,WAAW,CAAC;AAChD,CAAC,CACF;AAED,OAAO,MAAMC,kBAAkB,GAAGZ,MAAM,CAAkB,CAAC,CACzDC,OAAO,CACL,CAACY,GAAG,EAAEC,GAAG,MAAM;EACbC,MAAM,EAAEb,UAAU;EAClBc,SAAS,EAAE,KAAK;EAEhBC,eAAe,EAAEA,CAAA,KAAM;IACrB,OAAOH,GAAG,CAAC,CAAC,CAACC,MAAM,CAACG,MAAM,CAACC,KAAK,IAAIA,KAAK,CAACX,QAAQ,CAAC;EACrD,CAAC;EAEDY,iBAAiB,EAAGC,WAAmB,IAAK;IAC1C,OAAOP,GAAG,CAAC,CAAC,CAACC,MAAM,CAACG,MAAM,CACxBC,KAAK,IAAIA,KAAK,CAACX,QAAQ,IAAIa,WAAW,IAAIF,KAAK,CAACb,aAClD,CAAC;EACH,CAAC;EAEDgB,YAAY,EAAGD,WAAmB,IAAK;IACrC,MAAME,YAAY,GAAGT,GAAG,CAAC,CAAC,CAACG,eAAe,CAAC,CAAC;IAC5C,MAAMO,gBAAgB,GAAGD,YAAY,CAClCL,MAAM,CAACC,KAAK,IAAIA,KAAK,CAACb,aAAa,GAAGe,WAAW,CAAC,CAClDI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACpB,aAAa,GAAGqB,CAAC,CAACrB,aAAa,CAAC;IAEpD,OAAOkB,gBAAgB,CAAC,CAAC,CAAC,IAAI,IAAI;EACpC,CAAC;EAEDI,QAAQ,EAAE,MAAOC,SAAS,IAAK;IAC7BhB,GAAG,CAAC;MAAEG,SAAS,EAAE;IAAK,CAAC,CAAC;;IAExB;IACA,MAAM,IAAIc,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;IAEtD,MAAME,QAAmB,GAAG;MAC1B,GAAGJ,SAAS;MACZ1B,EAAE,EAAEO,IAAI,CAACwB,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;MACzB1B,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACpC,CAAC;IAEDE,GAAG,CAACuB,KAAK,KAAK;MACZrB,MAAM,EAAE,CAAC,GAAGqB,KAAK,CAACrB,MAAM,EAAEkB,QAAQ,CAAC;MACnCjB,SAAS,EAAE;IACb,CAAC,CAAC,CAAC;EACL,CAAC;EAEDqB,WAAW,EAAE,MAAAA,CAAOC,OAAO,EAAEC,OAAO,KAAK;IACvC1B,GAAG,CAAC;MAAEG,SAAS,EAAE;IAAK,CAAC,CAAC;;IAExB;IACA,MAAM,IAAIc,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;IAEtDlB,GAAG,CAACuB,KAAK,KAAK;MACZrB,MAAM,EAAEqB,KAAK,CAACrB,MAAM,CAACyB,GAAG,CAACrB,KAAK,IAC5BA,KAAK,CAAChB,EAAE,KAAKmC,OAAO,GAAG;QAAE,GAAGnB,KAAK;QAAE,GAAGoB;MAAQ,CAAC,GAAGpB,KACpD,CAAC;MACDH,SAAS,EAAE;IACb,CAAC,CAAC,CAAC;EACL,CAAC;EAEDyB,WAAW,EAAE,MAAOH,OAAO,IAAK;IAC9BzB,GAAG,CAAC;MAAEG,SAAS,EAAE;IAAK,CAAC,CAAC;;IAExB;IACA,MAAM,IAAIc,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;IAEtDlB,GAAG,CAACuB,KAAK,KAAK;MACZrB,MAAM,EAAEqB,KAAK,CAACrB,MAAM,CAACG,MAAM,CAACC,KAAK,IAAIA,KAAK,CAAChB,EAAE,KAAKmC,OAAO,CAAC;MAC1DtB,SAAS,EAAE;IACb,CAAC,CAAC,CAAC;EACL;AACF,CAAC,CAAC,EACF;EACE0B,IAAI,EAAE;AACR,CACF,CACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}