{"ast":null,"code":"import _objectSpread from \"/Users/halteverbotsocialmacpro/Desktop/ars vivai/Worky Time/worky-time-web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { OpenAIError } from \"../error.mjs\";\nimport { isAutoParsableResponseFormat } from \"../lib/parser.mjs\";\nexport function maybeParseResponse(response, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return _objectSpread(_objectSpread({}, response), {}, {\n      output_parsed: null,\n      output: response.output.map(item => {\n        if (item.type === 'function_call') {\n          return _objectSpread(_objectSpread({}, item), {}, {\n            parsed_arguments: null\n          });\n        }\n        if (item.type === 'message') {\n          return _objectSpread(_objectSpread({}, item), {}, {\n            content: item.content.map(content => _objectSpread(_objectSpread({}, content), {}, {\n              parsed: null\n            }))\n          });\n        } else {\n          return item;\n        }\n      })\n    });\n  }\n  return parseResponse(response, params);\n}\nexport function parseResponse(response, params) {\n  const output = response.output.map(item => {\n    if (item.type === 'function_call') {\n      return _objectSpread(_objectSpread({}, item), {}, {\n        parsed_arguments: parseToolCall(params, item)\n      });\n    }\n    if (item.type === 'message') {\n      const content = item.content.map(content => {\n        if (content.type === 'output_text') {\n          return _objectSpread(_objectSpread({}, content), {}, {\n            parsed: parseTextFormat(params, content.text)\n          });\n        }\n        return content;\n      });\n      return _objectSpread(_objectSpread({}, item), {}, {\n        content\n      });\n    }\n    return item;\n  });\n  const parsed = Object.assign({}, response, {\n    output\n  });\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n    addOutputText(parsed);\n  }\n  Object.defineProperty(parsed, 'output_parsed', {\n    enumerable: true,\n    get() {\n      for (const output of parsed.output) {\n        if (output.type !== 'message') {\n          continue;\n        }\n        for (const content of output.content) {\n          if (content.type === 'output_text' && content.parsed !== null) {\n            return content.parsed;\n          }\n        }\n      }\n      return null;\n    }\n  });\n  return parsed;\n}\nfunction parseTextFormat(params, content) {\n  var _params$text, _params$text2;\n  if (((_params$text = params.text) === null || _params$text === void 0 || (_params$text = _params$text.format) === null || _params$text === void 0 ? void 0 : _params$text.type) !== 'json_schema') {\n    return null;\n  }\n  if ('$parseRaw' in ((_params$text2 = params.text) === null || _params$text2 === void 0 ? void 0 : _params$text2.format)) {\n    var _params$text3;\n    const text_format = (_params$text3 = params.text) === null || _params$text3 === void 0 ? void 0 : _params$text3.format;\n    return text_format.$parseRaw(content);\n  }\n  return JSON.parse(content);\n}\nexport function hasAutoParseableInput(params) {\n  var _params$text4;\n  if (isAutoParsableResponseFormat((_params$text4 = params.text) === null || _params$text4 === void 0 ? void 0 : _params$text4.format)) {\n    return true;\n  }\n  return false;\n}\nexport function makeParseableResponseTool(tool, _ref) {\n  let {\n    parser,\n    callback\n  } = _ref;\n  const obj = _objectSpread({}, tool);\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableTool(tool) {\n  return (tool === null || tool === void 0 ? void 0 : tool['$brand']) === 'auto-parseable-tool';\n}\nfunction getInputToolByName(input_tools, name) {\n  return input_tools.find(tool => tool.type === 'function' && tool.name === name);\n}\nfunction parseToolCall(params, toolCall) {\n  var _params$tools;\n  const inputTool = getInputToolByName((_params$tools = params.tools) !== null && _params$tools !== void 0 ? _params$tools : [], toolCall.name);\n  return _objectSpread(_objectSpread(_objectSpread({}, toolCall), toolCall), {}, {\n    parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool !== null && inputTool !== void 0 && inputTool.strict ? JSON.parse(toolCall.arguments) : null\n  });\n}\nexport function shouldParseToolCall(params, toolCall) {\n  var _params$tools2;\n  if (!params) {\n    return false;\n  }\n  const inputTool = getInputToolByName((_params$tools2 = params.tools) !== null && _params$tools2 !== void 0 ? _params$tools2 : [], toolCall.name);\n  return isAutoParsableTool(inputTool) || (inputTool === null || inputTool === void 0 ? void 0 : inputTool.strict) || false;\n}\nexport function validateInputTools(tools) {\n  for (const tool of tools !== null && tools !== void 0 ? tools : []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(\"Currently only `function` tool types support auto-parsing; Received `\".concat(tool.type, \"`\"));\n    }\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(\"The `\".concat(tool.function.name, \"` tool is not marked with `strict: true`. Only strict function tools can be auto-parsed\"));\n    }\n  }\n}\nexport function addOutputText(rsp) {\n  const texts = [];\n  for (const output of rsp.output) {\n    if (output.type !== 'message') {\n      continue;\n    }\n    for (const content of output.content) {\n      if (content.type === 'output_text') {\n        texts.push(content.text);\n      }\n    }\n  }\n  rsp.output_text = texts.join('');\n}","map":{"version":3,"names":["OpenAIError","isAutoParsableResponseFormat","maybeParseResponse","response","params","hasAutoParseableInput","_objectSpread","output_parsed","output","map","item","type","parsed_arguments","content","parsed","parseResponse","parseToolCall","parseTextFormat","text","Object","assign","getOwnPropertyDescriptor","addOutputText","defineProperty","enumerable","get","_params$text","_params$text2","format","_params$text3","text_format","$parseRaw","JSON","parse","_params$text4","makeParseableResponseTool","tool","_ref","parser","callback","obj","defineProperties","$brand","value","$callback","isAutoParsableTool","getInputToolByName","input_tools","name","find","toolCall","_params$tools","inputTool","tools","arguments","strict","shouldParseToolCall","_params$tools2","validateInputTools","concat","function","rsp","texts","push","output_text","join"],"sources":["/Users/halteverbotsocialmacpro/Desktop/ars vivai/Worky Time/worky-time-web/node_modules/openai/src/lib/ResponsesParser.ts"],"sourcesContent":["import { OpenAIError } from '../error';\nimport type { ChatCompletionTool } from '../resources/chat/completions';\nimport {\n  ResponseTextConfig,\n  type FunctionTool,\n  type ParsedContent,\n  type ParsedResponse,\n  type ParsedResponseFunctionToolCall,\n  type ParsedResponseOutputItem,\n  type Response,\n  type ResponseCreateParamsBase,\n  type ResponseCreateParamsNonStreaming,\n  type ResponseFunctionToolCall,\n  type Tool,\n} from '../resources/responses/responses';\nimport { type AutoParseableTextFormat, isAutoParsableResponseFormat } from '../lib/parser';\n\nexport type ParseableToolsParams = Array<Tool> | ChatCompletionTool | null;\n\nexport type ResponseCreateParamsWithTools = ResponseCreateParamsBase & {\n  tools?: ParseableToolsParams;\n};\n\ntype TextConfigParams = { text?: ResponseTextConfig };\n\nexport type ExtractParsedContentFromParams<Params extends TextConfigParams> =\n  NonNullable<Params['text']>['format'] extends AutoParseableTextFormat<infer P> ? P : null;\n\nexport function maybeParseResponse<\n  Params extends ResponseCreateParamsBase | null,\n  ParsedT = Params extends null ? null : ExtractParsedContentFromParams<NonNullable<Params>>,\n>(response: Response, params: Params): ParsedResponse<ParsedT> {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...response,\n      output_parsed: null,\n      output: response.output.map((item) => {\n        if (item.type === 'function_call') {\n          return {\n            ...item,\n            parsed_arguments: null,\n          };\n        }\n\n        if (item.type === 'message') {\n          return {\n            ...item,\n            content: item.content.map((content) => ({\n              ...content,\n              parsed: null,\n            })),\n          };\n        } else {\n          return item;\n        }\n      }),\n    };\n  }\n\n  return parseResponse(response, params);\n}\n\nexport function parseResponse<\n  Params extends ResponseCreateParamsBase,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(response: Response, params: Params): ParsedResponse<ParsedT> {\n  const output: Array<ParsedResponseOutputItem<ParsedT>> = response.output.map(\n    (item): ParsedResponseOutputItem<ParsedT> => {\n      if (item.type === 'function_call') {\n        return {\n          ...item,\n          parsed_arguments: parseToolCall(params, item),\n        };\n      }\n      if (item.type === 'message') {\n        const content: Array<ParsedContent<ParsedT>> = item.content.map((content) => {\n          if (content.type === 'output_text') {\n            return {\n              ...content,\n              parsed: parseTextFormat(params, content.text),\n            };\n          }\n\n          return content;\n        });\n\n        return {\n          ...item,\n          content,\n        };\n      }\n\n      return item;\n    },\n  );\n\n  const parsed: Omit<ParsedResponse<ParsedT>, 'output_parsed'> = Object.assign({}, response, { output });\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n    addOutputText(parsed);\n  }\n\n  Object.defineProperty(parsed, 'output_parsed', {\n    enumerable: true,\n    get() {\n      for (const output of parsed.output) {\n        if (output.type !== 'message') {\n          continue;\n        }\n\n        for (const content of output.content) {\n          if (content.type === 'output_text' && content.parsed !== null) {\n            return content.parsed;\n          }\n        }\n      }\n\n      return null;\n    },\n  });\n\n  return parsed as ParsedResponse<ParsedT>;\n}\n\nfunction parseTextFormat<\n  Params extends ResponseCreateParamsBase,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(params: Params, content: string): ParsedT | null {\n  if (params.text?.format?.type !== 'json_schema') {\n    return null;\n  }\n\n  if ('$parseRaw' in params.text?.format) {\n    const text_format = params.text?.format as unknown as AutoParseableTextFormat<ParsedT>;\n    return text_format.$parseRaw(content);\n  }\n\n  return JSON.parse(content);\n}\n\nexport function hasAutoParseableInput(params: ResponseCreateParamsWithTools): boolean {\n  if (isAutoParsableResponseFormat(params.text?.format)) {\n    return true;\n  }\n\n  return false;\n}\n\ntype ToolOptions = {\n  name: string;\n  arguments: any;\n  function?: ((args: any) => any) | undefined;\n};\n\nexport type AutoParseableResponseTool<\n  OptionsT extends ToolOptions,\n  HasFunction = OptionsT['function'] extends Function ? true : false,\n> = FunctionTool & {\n  __arguments: OptionsT['arguments']; // type-level only\n  __name: OptionsT['name']; // type-level only\n\n  $brand: 'auto-parseable-tool';\n  $callback: ((args: OptionsT['arguments']) => any) | undefined;\n  $parseRaw(args: string): OptionsT['arguments'];\n};\n\nexport function makeParseableResponseTool<OptionsT extends ToolOptions>(\n  tool: FunctionTool,\n  {\n    parser,\n    callback,\n  }: {\n    parser: (content: string) => OptionsT['arguments'];\n    callback: ((args: any) => any) | undefined;\n  },\n): AutoParseableResponseTool<OptionsT['arguments']> {\n  const obj = { ...tool };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n    $callback: {\n      value: callback,\n      enumerable: false,\n    },\n  });\n\n  return obj as AutoParseableResponseTool<OptionsT['arguments']>;\n}\n\nexport function isAutoParsableTool(tool: any): tool is AutoParseableResponseTool<any> {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\n\nfunction getInputToolByName(input_tools: Array<Tool>, name: string): FunctionTool | undefined {\n  return input_tools.find((tool) => tool.type === 'function' && tool.name === name) as\n    | FunctionTool\n    | undefined;\n}\n\nfunction parseToolCall<Params extends ResponseCreateParamsBase>(\n  params: Params,\n  toolCall: ResponseFunctionToolCall,\n): ParsedResponseFunctionToolCall {\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n\n  return {\n    ...toolCall,\n    ...toolCall,\n    parsed_arguments:\n      isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments)\n      : inputTool?.strict ? JSON.parse(toolCall.arguments)\n      : null,\n  };\n}\n\nexport function shouldParseToolCall(\n  params: ResponseCreateParamsNonStreaming | null | undefined,\n  toolCall: ResponseFunctionToolCall,\n): boolean {\n  if (!params) {\n    return false;\n  }\n\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\n\nexport function validateInputTools(tools: ChatCompletionTool[] | undefined) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(\n        `Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``,\n      );\n    }\n\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(\n        `The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`,\n      );\n    }\n  }\n}\n\nexport function addOutputText(rsp: Response): void {\n  const texts: string[] = [];\n  for (const output of rsp.output) {\n    if (output.type !== 'message') {\n      continue;\n    }\n\n    for (const content of output.content) {\n      if (content.type === 'output_text') {\n        texts.push(content.text);\n      }\n    }\n  }\n\n  rsp.output_text = texts.join('');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}